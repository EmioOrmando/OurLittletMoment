<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>üíú</title>
  <style>
    :root{
      --bg:#000;
      --p1:#8b5cf6;
      --p2:#a78bfa;
      --p3:#5b21b6;
      --txt:rgba(255,255,255,0.88);
      --muted:rgba(255,255,255,0.62);
      --border:rgba(139,92,246,0.28);
    }
    html,body{height:100%;margin:0;background:var(--bg);overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
    canvas{display:block;width:100vw;height:100vh;image-rendering: pixelated;}

    .hud{
      position:fixed;
      left:50%;
      bottom:16px;
      transform:translateX(-50%);
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:center;
      flex-wrap:wrap;
      padding:10px 12px;
      border-radius:999px;
      background: rgba(0,0,0,0.55);
      border:1px solid var(--border);
      backdrop-filter: blur(8px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.55);
      color:var(--txt);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    button{
      background: rgba(139,92,246,0.14);
      color: #fff;
      border: 1px solid rgba(139,92,246,0.35);
      padding: 10px 14px;
      border-radius: 999px;
      cursor: pointer;
      font-weight: 650;
    }
    button:hover{ background: rgba(139,92,246,0.22); }
    .status{min-width:220px;font-size:13px;opacity:0.92;text-align:center;}
    .tip{
      position:fixed;
      top:14px;
      left:50%;
      transform:translateX(-50%);
      padding:10px 14px;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(139,92,246,0.14), rgba(139,92,246,0.06));
      border:1px solid var(--border);
      color:var(--muted);
      font-size:13px;
      text-align:center;
      max-width:min(760px, 92vw);
      box-shadow: 0 18px 60px rgba(0,0,0,0.6);
    }
    .tip strong{color:var(--txt); font-weight:700;}
    @media (prefers-reduced-motion: reduce){
      .tip{display:none;}
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="tip">
    Click/tap anywhere to start music (autoplay is blocked by browsers).
    If audio fails, the status tells you why.
    Optional: add <strong>scene.png</strong> to match your reference even closer.
  </div>

  <div class="hud" id="tapArea" role="button" tabindex="0" aria-label="Play or pause music">
    <button id="playBtn" type="button">Play</button>
    <button id="pauseBtn" type="button">Pause</button>
    <div class="status" id="status">Ready.</div>
  </div>

  <audio id="bgm" src="song.mp3" preload="auto" loop></audio>

<script>
(() => {
  // ---------- Audio (with real diagnostics) ----------
  const audio = document.getElementById('bgm');
  const statusEl = document.getElementById('status');
  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const tapArea = document.getElementById('tapArea');

  const setStatus = (m) => statusEl.textContent = m || "";

  audio.addEventListener('error', () => {
    const code = audio.error ? audio.error.code : 0;
    const msg =
      code === 2 ? "Audio load failed (404/path). Check song.mp3 name/case + location." :
      code === 3 ? "Audio decode failed. Re-export MP3 (CBR 128‚Äì320kbps) and re-upload." :
      code === 4 ? "Audio not supported. Use .mp3 or .m4a." :
      "Audio error. Check song.mp3 exists at the same path as index.html.";
    setStatus(msg);
  });

  async function playAudio(){
    try{
      audio.volume = 0.85;
      await audio.play(); // must be user gesture
      setStatus("Playing ‚ô´ (tap canvas to pause/play)");
    }catch{
      setStatus("Autoplay blocked ‚Äî click/tap once to start the music.");
    }
  }
  function pauseAudio(){ audio.pause(); setStatus("Paused"); }
  function toggleAudio(){ audio.paused ? playAudio() : pauseAudio(); }

  playBtn.addEventListener('click', playAudio);
  pauseBtn.addEventListener('click', pauseAudio);

  // Help you catch missing file on Pages
  fetch("song.mp3", { method: "GET", cache: "no-store" })
    .then(r => { if(!r.ok) throw 0; setStatus("Song found. Click/tap to play ‚ô´"); })
    .catch(() => setStatus("song.mp3 not found (likely 404). Check filename/case + repo path."));

  // ---------- Canvas / Pixel world ----------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width  = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.imageSmoothingEnabled = false;
  }
  addEventListener('resize', resize);
  resize();

  const CSS = getComputedStyle(document.documentElement);
  const C = {
    bg: "#000000",
    sky1: "#181427",
    sky2: "#0c0a14",
    p1: CSS.getPropertyValue('--p1').trim(),
    p2: CSS.getPropertyValue('--p2').trim(),
    p3: CSS.getPropertyValue('--p3').trim(),
    rail: "rgba(167,139,250,0.45)",
    fog: "rgba(139,92,246,0.10)",
    star: "rgba(167,139,250,0.85)",
    dim: "rgba(167,139,250,0.25)",
    black: "#07060a"
  };

  // Optional background image (drop scene.png next to index.html)
  const bgImg = new Image();
  let hasBgImg = false;
  bgImg.onload = () => { hasBgImg = true; };
  bgImg.onerror = () => { hasBgImg = false; };
  bgImg.src = "scene.png";

  // Pixel stars (like your reference)
  const stars = Array.from({length: 28}, () => ({
    x: Math.random() * innerWidth,
    y: Math.random() * innerHeight * 0.6,
    s: (Math.random() < 0.18) ? 3 : 2,
    a: 0.45 + Math.random()*0.5,
    t: Math.random()*1000
  }));

  function drawSceneProcedural(t){
    // Sky gradient
    const g = ctx.createLinearGradient(0,0,0,innerHeight);
    g.addColorStop(0, C.sky1);
    g.addColorStop(1, C.sky2);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,innerWidth,innerHeight);

    // Stars (chunky)
    for(const s of stars){
      const tw = 0.65 + 0.35*Math.sin((t*0.001) + s.t);
      ctx.fillStyle = `rgba(167,139,250,${(s.a*tw).toFixed(3)})`;
      ctx.fillRect(s.x, s.y, s.s, s.s);
    }

    // Moon (pixel-ish circle)
    const mx = innerWidth*0.5;
    const my = innerHeight*0.22;
    const r  = Math.min(innerWidth, innerHeight) * 0.12;

    // Glow
    const mg = ctx.createRadialGradient(mx,my,0,mx,my,r*2.2);
    mg.addColorStop(0, "rgba(167,139,250,0.12)");
    mg.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = mg;
    ctx.fillRect(mx-r*2.2, my-r*2.2, r*4.4, r*4.4);

    // Moon body
    ctx.fillStyle = C.p2;
    // draw as chunky circle using rect steps
    const step = 4;
    for(let y=-r; y<=r; y+=step){
      for(let x=-r; x<=r; x+=step){
        if(x*x + y*y <= r*r) ctx.fillRect(mx+x, my+y, step, step);
      }
    }

    // Clouds (pixel blocks)
    function cloud(cx, cy, w, h){
      ctx.fillStyle = "rgba(167,139,250,0.35)";
      const px = 6;
      for(let i=0;i<70;i++){
        const x = cx + (Math.random()-0.5)*w;
        const y = cy + (Math.random()-0.5)*h;
        const ww = px*(2+Math.floor(Math.random()*4));
        const hh = px*(1+Math.floor(Math.random()*3));
        ctx.fillRect(x,y,ww,hh);
      }
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      for(let i=0;i<35;i++){
        const x = cx + (Math.random()-0.5)*w;
        const y = cy + (Math.random()-0.5)*h;
        const ww = px*(2+Math.floor(Math.random()*4));
        const hh = px*(1+Math.floor(Math.random()*3));
        ctx.fillRect(x,y+px,ww,hh);
      }
    }
    cloud(innerWidth*0.15, innerHeight*0.28, innerWidth*0.25, innerHeight*0.10);
    cloud(innerWidth*0.85, innerHeight*0.30, innerWidth*0.25, innerHeight*0.10);

    // Forest silhouette band
    const forestY = innerHeight*0.68;
    ctx.fillStyle = "rgba(139,92,246,0.18)";
    for(let i=0;i<42;i++){
      const x = i*(innerWidth/42);
      const h = innerHeight*0.12 + Math.random()*innerHeight*0.10;
      ctx.fillRect(x, forestY - h, innerWidth/42 - 2, h);
    }

    // Railing (like your reference)
    const railTop = innerHeight*0.78;
    const railBot = innerHeight*0.92;
    ctx.fillStyle = "rgba(167,139,250,0.34)";
    ctx.fillRect(0, railTop, innerWidth, 6);
    ctx.fillRect(0, railBot, innerWidth, 6);

    // Vertical posts
    const postW = 8;
    for(let x=0; x<innerWidth; x += Math.max(80, innerWidth/10)){
      ctx.fillRect(x, railTop, postW, railBot-railTop);
    }
    // Middle bar
    ctx.fillStyle = "rgba(167,139,250,0.22)";
    ctx.fillRect(0, (railTop+railBot)/2, innerWidth, 4);
  }

  // Pixel couple that matches your reference: black silhouettes with purple rim light.
  // Two frames => gentle ‚Äúdance/sway‚Äù.
  const coupleFrames = [
    [
      "................",
      ".....BBB..BBB...",
      "....BBBBBBBBB...",
      "...BBBBBBBBBB...",
      "...BBBBBBBBBB...",
      "...BBBBBBBBBB...",
      "...BBBBBBBBBB...",
      "...BBBBBBBBBB...",
      "....BBBBBBBB....",
      ".....BBBBBB.....",
      "..BB..BB..BB....",
      "..BB..BB..BB....",
      "..BB..BB..BB....",
      "..BB..BB..BB....",
      "..BB..BB..BB....",
      "...BB....BB.....",
      "...BB....BB.....",
      "................",
    ],
    [
      "................",
      ".....BBB..BBB...",
      "....BBBBBBBBB...",
      "...BBBBBBBBBB...",
      "...BBBBBBBBBB...",
      "...BBBBBBBBBB...",
      "...BBBBBBBBBB...",
      "....BBBBBBBBB...",
      ".....BBBBBBB....",
      "......BBBBB.....",
      "..BB..BB..BB....",
      "..BB..BB..BB....",
      "..BB..BB..BB....",
      "..BB..BB..BB....",
      "...BB....BB.....",
      "...BB....BB.....",
      "...BB....BB.....",
      "................",
    ]
  ];

  function drawCouplePixel(frame, x, y, px){
    // Body
    ctx.fillStyle = C.black;
    for(let r=0;r<frame.length;r++){
      const row = frame[r];
      for(let c=0;c<row.length;c++){
        if(row[c] !== 'B') continue;
        ctx.fillRect(x + c*px, y + r*px, px, px);
      }
    }
    // Rim light (purple outline on right edge & top-ish like your reference)
    ctx.fillStyle = "rgba(167,139,250,0.65)";
    for(let r=0;r<frame.length;r++){
      const row = frame[r];
      for(let c=0;c<row.length;c++){
        if(row[c] !== 'B') continue;
        // outline if neighbor is empty on right/top
        const rightEmpty = (c === row.length-1) || (row[c+1] !== 'B');
        const topEmpty = (r === 0) || (frame[r-1][c] !== 'B');
        if(rightEmpty || topEmpty){
          ctx.fillRect(x + c*px, y + r*px, px, px);
        }
      }
    }
    // Hand ‚Äúspark‚Äù between them
    ctx.fillStyle = "rgba(167,139,250,0.90)";
    ctx.fillRect(x + 8*px, y + 9*px, px, px);
  }

  // Interaction: click canvas toggles music
  function gestureToggle(){
    toggleAudio();
    energy = 1.0;
  }
  document.addEventListener('pointerdown', gestureToggle, { passive:true });
  tapArea.addEventListener('keydown', (e) => {
    if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); gestureToggle(); }
  });

  // Animation
  let last = performance.now();
  let phase = 0;
  let energy = 0;

  function render(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;

    // Background: image if present, else procedural
    if(hasBgImg){
      // Cover-fit image like wallpaper
      const iw = bgImg.naturalWidth || 1;
      const ih = bgImg.naturalHeight || 1;
      const s = Math.max(innerWidth/iw, innerHeight/ih);
      const dw = iw*s, dh = ih*s;
      const dx = (innerWidth - dw)/2;
      const dy = (innerHeight - dh)/2;
      ctx.drawImage(bgImg, dx, dy, dw, dh);
      // subtle purple tint
      ctx.fillStyle = "rgba(139,92,246,0.06)";
      ctx.fillRect(0,0,innerWidth,innerHeight);
    }else{
      drawSceneProcedural(now);
    }

    // Couple placement (bottom center on ‚Äúbridge‚Äù)
    const px = Math.max(6, Math.min(14, Math.min(innerWidth,innerHeight)/70));
    const frameIndex = (Math.floor(phase) % 2);
    const frame = coupleFrames[frameIndex];

    const coupleW = frame[0].length * px;
    const coupleH = frame.length * px;

    const baseX = innerWidth*0.5 - coupleW/2;
    const baseY = innerHeight*0.78 - coupleH*0.72;

    // Dance/sway
    const beat = (!audio.paused ? audio.currentTime : now/1000);
    phase += dt * (2.0 + energy*0.9);
    energy = Math.max(0, energy - dt*0.8);

    const sway = Math.sin(phase*1.1) * (6 + energy*6);
    const bob  = Math.sin(phase*2.2) * (4 + energy*4);

    // Purple glow behind couple (like the moon vibe)
    const gx = innerWidth*0.5, gy = innerHeight*0.70;
    const gr = Math.min(innerWidth,innerHeight) * 0.18;
    const glow = ctx.createRadialGradient(gx,gy,0,gx,gy,gr);
    glow.addColorStop(0, "rgba(139,92,246,0.16)");
    glow.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = glow;
    ctx.fillRect(gx-gr, gy-gr, gr*2, gr*2);

    ctx.save();
    ctx.translate(innerWidth*0.5, baseY + coupleH*0.6);
    ctx.rotate(Math.sin(phase*0.65) * (0.04 + energy*0.02));
    ctx.translate(-innerWidth*0.5, -(baseY + coupleH*0.6));

    drawCouplePixel(frame, baseX + sway, baseY + bob, px);

    ctx.restore();

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
})();
</script>
</body>
</html>
