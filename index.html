<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>üíú</title>
  <style>
    :root{
      --bg:#000;
      --p1:#8b5cf6;
      --p2:#a78bfa;
      --p3:#5b21b6;
      --txt:rgba(255,255,255,0.88);
      --muted:rgba(255,255,255,0.62);
      --border:rgba(139,92,246,0.28);
    }
    html,body{height:100%;margin:0;background:var(--bg);overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
    canvas{display:block;width:100vw;height:100vh;image-rendering: pixelated;}

    .hud{
      position:fixed;
      left:50%;
      bottom:16px;
      transform:translateX(-50%);
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:center;
      flex-wrap:wrap;
      padding:10px 12px;
      border-radius:999px;
      background: rgba(0,0,0,0.55);
      border:1px solid var(--border);
      backdrop-filter: blur(8px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.55);
      color:var(--txt);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    button{
      background: rgba(139,92,246,0.14);
      color: #fff;
      border: 1px solid rgba(139,92,246,0.35);
      padding: 10px 14px;
      border-radius: 999px;
      cursor: pointer;
      font-weight: 650;
    }
    button:hover{ background: rgba(139,92,246,0.22); }
    .status{min-width:220px;font-size:13px;opacity:0.92;text-align:center;}
    .tip{
      position:fixed;
      top:14px;
      left:50%;
      transform:translateX(-50%);
      padding:10px 14px;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(139,92,246,0.14), rgba(139,92,246,0.06));
      border:1px solid var(--border);
      color:var(--muted);
      font-size:13px;
      text-align:center;
      max-width:min(760px, 92vw);
      box-shadow: 0 18px 60px rgba(0,0,0,0.6);
    }
    .tip strong{color:var(--txt); font-weight:700;}
    @media (prefers-reduced-motion: reduce){
      .tip{display:none;}
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="tip">
    Click/tap anywhere to start music (autoplay is blocked by browsers).
    If audio fails, the status tells you why.
  </div>

  <div class="hud" id="tapArea" role="button" tabindex="0" aria-label="Play or pause music">
    <button id="playBtn" type="button">Play</button>
    <button id="pauseBtn" type="button">Pause</button>
    <div class="status" id="status">Ready.</div>
  </div>

  <audio id="bgm" src="song.mp3" preload="auto" loop></audio>

<script>
(() => {
  // ---------- Audio (diagnostics) ----------
  const audio = document.getElementById('bgm');
  const statusEl = document.getElementById('status');
  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const tapArea = document.getElementById('tapArea');
  const setStatus = (m) => statusEl.textContent = m || "";

  audio.addEventListener('error', () => {
    const code = audio.error ? audio.error.code : 0;
    const msg =
      code === 2 ? "Audio load failed (404/path). Check song.mp3 name/case + location." :
      code === 3 ? "Audio decode failed. Re-export MP3 (CBR 128‚Äì320kbps) and re-upload." :
      code === 4 ? "Audio not supported. Use .mp3 or .m4a." :
      "Audio error. Check song.mp3 exists at the same path as index.html.";
    setStatus(msg);
  });

  async function playAudio(){
    try{
      audio.volume = 0.85;
      await audio.play();
      setStatus("Playing ‚ô´ (tap canvas to pause/play)");
    }catch{
      setStatus("Autoplay blocked ‚Äî click/tap once to start the music.");
    }
  }
  function pauseAudio(){ audio.pause(); setStatus("Paused"); }
  function toggleAudio(){ audio.paused ? playAudio() : pauseAudio(); }

  playBtn.addEventListener('click', playAudio);
  pauseBtn.addEventListener('click', pauseAudio);

  fetch("song.mp3", { method: "GET", cache: "no-store" })
    .then(r => { if(!r.ok) throw 0; setStatus("Song found. Click/tap to play ‚ô´"); })
    .catch(() => setStatus("song.mp3 not found (likely 404). Check filename/case + repo path."));

  // ---------- Canvas / Pixel world ----------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width  = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.imageSmoothingEnabled = false;
  }
  addEventListener('resize', resize);
  resize();

  const CSS = getComputedStyle(document.documentElement);
  const C = {
    bg: "#000000",
    sky1: "#181427",
    sky2: "#0c0a14",
    p1: CSS.getPropertyValue('--p1').trim(),
    p2: CSS.getPropertyValue('--p2').trim(),
    p3: CSS.getPropertyValue('--p3').trim(),
    rail: "rgba(167,139,250,0.45)",
    fog: "rgba(139,92,246,0.10)",
    star: "rgba(167,139,250,0.85)",
    dim: "rgba(167,139,250,0.25)",
    black: "#07060a"
  };

  // Stars (chunky)
  const stars = Array.from({length: 28}, () => ({
    x: Math.random() * innerWidth,
    y: Math.random() * innerHeight * 0.6,
    s: (Math.random() < 0.18) ? 3 : 2,
    a: 0.45 + Math.random()*0.5,
    t: Math.random()*1000
  }));

  function drawScene(t){
    // Sky gradient
    const g = ctx.createLinearGradient(0,0,0,innerHeight);
    g.addColorStop(0, C.sky1);
    g.addColorStop(1, C.sky2);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,innerWidth,innerHeight);

    // Stars
    for(const s of stars){
      const tw = 0.65 + 0.35*Math.sin((t*0.001) + s.t);
      ctx.fillStyle = `rgba(167,139,250,${(s.a*tw).toFixed(3)})`;
      ctx.fillRect(s.x, s.y, s.s, s.s);
    }

    // Moon
    const mx = innerWidth*0.5;
    const my = innerHeight*0.22;
    const r  = Math.min(innerWidth, innerHeight) * 0.12;

    const mg = ctx.createRadialGradient(mx,my,0,mx,my,r*2.2);
    mg.addColorStop(0, "rgba(167,139,250,0.12)");
    mg.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = mg;
    ctx.fillRect(mx-r*2.2, my-r*2.2, r*4.4, r*4.4);

    ctx.fillStyle = C.p2;
    const step = 4;
    for(let y=-r; y<=r; y+=step){
      for(let x=-r; x<=r; x+=step){
        if(x*x + y*y <= r*r) ctx.fillRect(mx+x, my+y, step, step);
      }
    }

    // Clouds
    function cloud(cx, cy, w, h){
      ctx.fillStyle = "rgba(167,139,250,0.35)";
      const px = 6;
      for(let i=0;i<70;i++){
        const x = cx + (Math.random()-0.5)*w;
        const y = cy + (Math.random()-0.5)*h;
        const ww = px*(2+Math.floor(Math.random()*4));
        const hh = px*(1+Math.floor(Math.random()*3));
        ctx.fillRect(x,y,ww,hh);
      }
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      for(let i=0;i<35;i++){
        const x = cx + (Math.random()-0.5)*w;
        const y = cy + (Math.random()-0.5)*h;
        const ww = px*(2+Math.floor(Math.random()*4));
        const hh = px*(1+Math.floor(Math.random()*3));
        ctx.fillRect(x,y+px,ww,hh);
      }
    }
    cloud(innerWidth*0.15, innerHeight*0.28, innerWidth*0.25, innerHeight*0.10);
    cloud(innerWidth*0.85, innerHeight*0.30, innerWidth*0.25, innerHeight*0.10);

    // Forest band
    const forestY = innerHeight*0.68;
    ctx.fillStyle = "rgba(139,92,246,0.18)";
    for(let i=0;i<42;i++){
      const x = i*(innerWidth/42);
      const h = innerHeight*0.12 + Math.random()*innerHeight*0.10;
      ctx.fillRect(x, forestY - h, innerWidth/42 - 2, h);
    }

    // Railing
    const railTop = innerHeight*0.78;
    const railBot = innerHeight*0.92;
    ctx.fillStyle = "rgba(167,139,250,0.34)";
    ctx.fillRect(0, railTop, innerWidth, 6);
    ctx.fillRect(0, railBot, innerWidth, 6);

    const postW = 8;
    for(let x=0; x<innerWidth; x += Math.max(80, innerWidth/10)){
      ctx.fillRect(x, railTop, postW, railBot-railTop);
    }
    ctx.fillStyle = "rgba(167,139,250,0.22)";
    ctx.fillRect(0, (railTop+railBot)/2, innerWidth, 4);
  }

  // ---------- Slow dancing couple (pixel art) ----------
  // Legend: 'B' silhouette black, 'R' purple rimlight, '.' empty
  // We draw black first, then rim pixels.
  const coupleFrames = [
    [
      "........................",
      "..........BB..BB........",
      ".........BBBBBBBB.......",
      "........BBBBBBBBBB......",
      ".......BBBBBBBBBBBB.....",
      ".......BBBBBBBBBBBB.....",
      ".......BBBBBBRBBBBB.....",
      "......BBBBBBRRBBBBB.....",
      "......BBBBBRRRRBBBB.....",
      "......BBBBRRRRRRBBB.....",
      "......BBBBRRRRRRBBB.....",
      "......BBBBBRRRRBBBB.....",
      ".......BBBBBRRBBBB......",
      "........BBBBBBBBB.......",
      "........BBBBBBBBB.......",
      ".......BBB..BB..BBB.....",
      ".......BBB..BB..BBB.....",
      ".......BBB..BB..BBB.....",
      "........BB......BB......",
      "........BB......BB......",
      "........BB......BB......",
      "........................"
    ],
    [
      "........................",
      "..........BB..BB........",
      ".........BBBBBBBB.......",
      "........BBBBBBBBBB......",
      ".......BBBBBBBBBBBB.....",
      ".......BBBBBBBBBBBB.....",
      ".......BBBBBBRBBBBB.....",
      "......BBBBBRRRBBBBB.....",
      "......BBBBRRRRRBBBB.....",
      "......BBBBRRRRRRBBB.....",
      "......BBBBRRRRRRBBB.....",
      "......BBBBRRRRRBBBB.....",
      ".......BBBBBRRBBBB......",
      "........BBBBBBBBB.......",
      "........BBBBBBBBB.......",
      ".......BBB..BB..BBB.....",
      ".......BBB..BB..BBB.....",
      ".......BBB..BB..BBB.....",
      "........BB......BB......",
      "........BB......BB......",
      "........BB......BB......",
      "........................"
    ],
    [
      "........................",
      "..........BB..BB........",
      ".........BBBBBBBB.......",
      "........BBBBBBBBBB......",
      ".......BBBBBBBBBBBB.....",
      ".......BBBBBBBBBBBB.....",
      ".......BBBBBBRBBBBB.....",
      "......BBBBBBRRBBBBB.....",
      "......BBBBRRRRRBBBB.....",
      "......BBBBRRRRRRBBB.....",
      "......BBBBRRRRRRBBB.....",
      "......BBBBRRRRRBBBB.....",
      ".......BBBBBRRBBBB......",
      "........BBBBBBBBB.......",
      "........BBBBBBBBB.......",
      ".......BBB..BB..BBB.....",
      ".......BBB..BB..BBB.....",
      ".......BBB..BB..BBB.....",
      "........BB......BB......",
      "........BB......BB......",
      "........BB......BB......",
      "........................"
    ],
    [
      "........................",
      "..........BB..BB........",
      ".........BBBBBBBB.......",
      "........BBBBBBBBBB......",
      ".......BBBBBBBBBBBB.....",
      ".......BBBBBBBBBBBB.....",
      ".......BBBBBBRBBBBB.....",
      "......BBBBBRRRBBBBB.....",
      "......BBBBRRRRRBBBB.....",
      "......BBBBRRRRRRBBB.....",
      "......BBBBRRRRRRBBB.....",
      "......BBBBRRRRRBBBB.....",
      ".......BBBBBRRBBBB......",
      "........BBBBBBBBB.......",
      "........BBBBBBBBB.......",
      ".......BBB..BB..BBB.....",
      ".......BBB..BB..BBB.....",
      ".......BBB..BB..BBB.....",
      "........BB......BB......",
      "........BB......BB......",
      "........BB......BB......",
      "........................"
    ]
  ];

  function drawCouple(frame, x, y, px){
    // Draw silhouette
    ctx.fillStyle = C.black;
    for(let r=0;r<frame.length;r++){
      const row = frame[r];
      for(let c=0;c<row.length;c++){
        if(row[c] === 'B'){
          ctx.fillRect(x + c*px, y + r*px, px, px);
        }
      }
    }
    // Rimlight: place on pixels that are silhouette but have empty neighbor (right/top)
    ctx.fillStyle = "rgba(167,139,250,0.75)";
    for(let r=0;r<frame.length;r++){
      const row = frame[r];
      for(let c=0;c<row.length;c++){
        if(row[c] !== 'B') continue;
        const rightEmpty = (c === row.length-1) || (row[c+1] !== 'B');
        const topEmpty   = (r === 0) || (frame[r-1][c] !== 'B');
        if(rightEmpty || topEmpty){
          ctx.fillRect(x + c*px, y + r*px, px, px);
        }
      }
    }
    // ‚ÄúHands‚Äù glow (tiny)
    ctx.fillStyle = "rgba(167,139,250,0.95)";
    ctx.fillRect(x + 14*px, y + 9*px, px, px);
    ctx.fillRect(x + 15*px, y + 9*px, px, px);
  }

  // Tap anywhere toggles music
  function gestureToggle(){ toggleAudio(); energy = 1.0; }
  document.addEventListener('pointerdown', gestureToggle, { passive:true });
  tapArea.addEventListener('keydown', (e) => {
    if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); gestureToggle(); }
  });

  // Animation
  let last = performance.now();
  let phase = 0;
  let energy = 0;

  function render(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;

    drawScene(now);

    // Couple: center, sitting just above top rail line
    const px = Math.max(6, Math.min(16, Math.min(innerWidth,innerHeight)/85));
    const beatTime = (!audio.paused ? audio.currentTime : now/1000);

    // slow dance tempo
    phase += dt * (1.25 + energy*0.6);
    energy = Math.max(0, energy - dt*0.7);

    // 4-frame swap synced to slow pulse
    const f = Math.floor((beatTime*1.2) % 4); // gentle
    const frame = coupleFrames[f];

    const w = frame[0].length * px;
    const h = frame.length * px;

    const railTop = innerHeight*0.78;
    const baseX = innerWidth*0.5 - w/2;
    const baseY = railTop - h*0.72;

    const sway = Math.sin(phase*0.9) * (0.06 + energy*0.02);
    const bob  = Math.sin(phase*2.0) * (3 + energy*3);

    // purple spotlight behind them (subtle)
    const gx = innerWidth*0.5, gy = railTop - h*0.15;
    const gr = Math.min(innerWidth,innerHeight) * 0.16;
    const glow = ctx.createRadialGradient(gx,gy,0,gx,gy,gr);
    glow.addColorStop(0, "rgba(139,92,246,0.14)");
    glow.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = glow;
    ctx.fillRect(gx-gr, gy-gr, gr*2, gr*2);

    // Draw the couple with gentle rotation around their ‚Äúfeet‚Äù
    ctx.save();
    ctx.translate(innerWidth*0.5, baseY + h*0.82);
    ctx.rotate(sway);
    ctx.translate(-innerWidth*0.5, -(baseY + h*0.82));

    drawCouple(frame, baseX, baseY + bob, px);

    ctx.restore();

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
})();
</script>
</body>
</html>
